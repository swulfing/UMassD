}
get_P_t_base <- function(fleet_regions, can_move, mig_type, time, F, M, mu) {
n_regions <- length(M)
n_fleets <- length(fleet_regions)
dim <- n_regions + n_fleets + 1
P <- matrix(0, nrow = dim, ncol = dim)
Z <- M
for (f in seq_along(F)) {
Z[fleet_regions[f]] <- Z[fleet_regions[f]] + F[f]
}
if (n_regions == 1) {  # Single region case (Baranov's equation)
if (time < 1e-15) {
P[1, 1] <- 1.0
} else {
P[1, 1] <- exp(-Z[1] * time)
for (f in seq_along(F)) {
P[1, 1 + f] <- F[f] * (1 - exp(-Z[1] * time)) / Z[1]
}
P[1, dim] <- 1 - sum(P[1, 1:(dim-1)])
}
diag(P)[-1] <- 1.0
} else {  # Multiple regions case
if (sum(can_move) > 0) {  # Migration scenario
if (mig_type == 0) {  # Migration after survival
if (time < 1e-15) {
P[1:n_regions, 1:n_regions] <- mu
} else {
for (f in seq_along(F)) {
P[fleet_regions[f], n_regions + f] <- F[f] * (1.0 - exp(-Z[fleet_regions[f]] * time)) / Z[fleet_regions[f]]
}
for (i in seq_len(n_regions)) {
for (j in seq_len(n_regions)) {
P[i, j] <- exp(-Z[i] * time) * mu[i, j]
}
P[i, dim] <- 1 - sum(P[i, 1:(dim-1)])
}
}
diag(P[(n_regions + 1):dim, (n_regions + 1):dim]) <- 1.0
} else if (mig_type == 1) {  # Continuous migration
if (time < 1e-15) {
diag(P[1:n_regions, 1:n_regions]) <- 1.0
} else {
A <- matrix(0, nrow = dim, ncol = dim)
for (i in seq_len(n_regions)) A[i, dim] <- M[i] + Z[i]
for (f in seq_along(F)) A[fleet_regions[f], n_regions + f] <- F[f]
for (i in seq_len(n_regions)) {
for (j in seq_len(n_regions)) {
if (i != j) A[i, j] <- mu[i, j]
}
}
diag(A[1:n_regions, 1:n_regions]) <- -rowSums(A[1:n_regions, ])
A <- A * time
P <- expm(A)
}
}
} else {  # No migration case
if (time < 1e-15) {
diag(P) <- 1.0
} else {
for (i in seq_len(n_regions)) {
P[i, i] <- exp(-Z[i] * time)
P[i, dim] <- M[i]*(1-exp(-Z[i]*time))/Z[i]
}
for (f in seq_along(F)) {
P[fleet_regions[f], n_regions + f] <- F[f] * (1 - exp(-Z[fleet_regions[f]] * time)) / Z[fleet_regions[f]]
}
diag(P[(n_regions + 1):dim, (n_regions + 1):dim]) <- 1.0
}
}
}
return(P)
}
get_P_t <- function(age, stock, season, fleet_regions, fleet_seasons,
can_move, mig_type, time, FAA, log_M, mu) {
n_regions <- dim(log_M)[2]  # Extract number of regions
get_F_t <- function(fleet_season, age, FAA) {
# Initialize F_t as a vector of zeros with the same length as the first dimension of FAA
F_t <- rep(0, dim(FAA)[1])
# Assign values where fleet is active
for (f in seq_along(F_t)) {
if (fleet_season[f] == 1) {  # Only assign if fleet is operating
F_t[f] <- FAA[f, age]
}
}
return(F_t)
}
# Extract fishing mortality for the given season and age
F <- get_F_t(fleet_seasons[, season], age, FAA)
# Initialize mortality and movement matrices
M <- rep(0, n_regions)
mu_stya <- matrix(0, n_regions, n_regions)
# Compute natural mortality M
for (r in 1:n_regions) {
M[r] <- exp(log_M[stock, r, age])
}
# Initialize can_move and movement rate matrices
can_move_sta <- matrix(0, n_regions, n_regions)
for (r in 1:n_regions) {
for (rr in 1:n_regions) {
can_move_sta[r, rr] <- can_move[stock, season, r, rr]
mu_stya[r, rr] <- mu[stock, age, season, r, rr]
}
}
# Compute transition probability matrix
P <- get_P_t_base(fleet_regions, can_move_sta, mig_type[stock], time, F, M, mu_stya)
return(P)
}
get_annual_Ps <- function(fleet_regions, fleet_seasons, can_move, mig_type, fracyr_seasons,
FAA, log_M, mu) {
# Extract dimensions
n_fleets <- dim(FAA)[1]
n_seasons <- ncol(fleet_seasons)
n_stocks <- dim(log_M)[1]
n_regions <- dim(log_M)[2]
n_ages <- dim(log_M)[3]
P_dim <- n_regions + n_fleets + 1  # Probability transition matrix dimensions
# Initialize annual probability transition array
annual_Ps <- array(0, dim = c(n_stocks, n_ages, P_dim, P_dim))
# Identity matrix for initialization
I_mat <- diag(1, P_dim, P_dim)
for (s in 1:n_stocks) {
for (a in 1:n_ages) {
P_y <- I_mat  # Reset for each year, age, stock
for (t in 1:n_seasons) {
# Compute probability transition matrix for season t
P_t <- get_P_t(a, s, t, fleet_regions, fleet_seasons, can_move, mig_type, fracyr_seasons[t], FAA, log_M, mu)
# Multiply season matrices together to get the annual transition matrix
P_y <- P_y %*% P_t
}
# Store the annual transition matrix
annual_Ps[s, a, , ] <- P_y
}
}
return(annual_Ps)
}
log_catch_fleets_F_multi_TEST <- function(log_F, NAA, log_M, mu, sel, fracyr_seasons, fleet_regions,
fleet_seasons, can_move, mig_type, waacatch) {
n_stocks <- dim(log_M)[1]
n_regions <- dim(log_M)[2]
n_seasons <- length(fracyr_seasons)
n_ages <- dim(log_M)[3]
n_fleets <- length(fleet_regions)
# Initialize FAA_T
FAA_T <- matrix(0, nrow = n_fleets, ncol = n_ages)
if (length(log_F) == n_fleets) {
for (f in 1:n_fleets) {
for (a in 1:n_ages) {
FAA_T[f, a] <- exp(log_F[f]) * sel[f, a] # use fleet-specific F
}
}
} else {
for (f in 1:n_fleets) {
for (a in 1:n_ages) {
FAA_T[f, a] <- exp(log_F[1]) * sel[f, a]  # Use global F
}
}
}
# Initialize Catch Matrix
catch_stock_fleet <- matrix(0, nrow = n_stocks, ncol = n_fleets)
Pdim <- n_regions + n_fleets + 1
I <- diag(Pdim)
for (s in 1:n_stocks) {
for (a in 1:n_ages) {
P_ya <- I
for (t in 1:n_seasons) {
P_ya <- P_ya %*% get_P_t(a, s, t, fleet_regions, fleet_seasons, can_move, mig_type, fracyr_seasons[t], FAA_T, log_M, mu)
}
for (r in 1:n_regions) {
for (f in 1:n_fleets) {
catch_stock_fleet[s, f] <- catch_stock_fleet[s, f] + NAA[s, r, a] * P_ya[r, n_regions + f] * waacatch[f, a]
}
}
}
}
# Should be same if directly using annual_Ps saved in the OM
# for (s in 1:n_stocks) {
#   for (a in 1:n_ages) {
#     for (r in 1:n_regions) {
#       for (f in 1:n_fleets) {
#         catch_stock_fleet[s, f] <- catch_stock_fleet[s, f] + NAA[s, r, a] * annual_Ps[s, a, r, n_regions + f] * waacatch[f, a]
#       }
#     }
#   }
# }
# Compute Fleet-Specific or Global Catch
if (n_fleets > 1) {
Catch <- colSums(catch_stock_fleet)
} else {
Catch <- sum(catch_stock_fleet)
}
return(log(Catch))
}
#'     \item Updated F time series.
#'     \item Simulated observation data.
#'     \item Updated random effect parameters.
#'   }
#'
#' @export
#'
#' @seealso \code{\link{get_F_from_Catch_TEST}}, \code{\link{update_om_F}}
#'
#'
update_om_fn_TEST <- function(om, interval.info = NULL, seed = 123, random = "log_NAA", method = "nlminb", by_fleet = TRUE, do.brps = FALSE) {
THEOMTHATGOESINTHEFUNCTION <<- om
browser()
if(!is.null(interval.info)){
# Iterative update F in the OM using get_F_from_Catch_TEST_region function
t <- 0
for (y in interval.info$years) {
year <- which(om$years == y)
t <- t + 1
Catch = interval.info$catch[t,]
rep <- om$rep #generate the reported values given the parameters
cat("\nNow calculating fleet-specific F in year ", y, "\n")
Fsolve <- get_F_from_Catch_TEST(om, Catch, year, method = "nlminb", by_fleet = by_fleet)
cat("\nFishing mortality is ", Fsolve, "\n")
cat("\nNow updating F in OM for year ", y, "\n")
om <- update_om_F(om, year, Fsolve)
# Names of observation data to update
obs_names <- c("agg_indices", "agg_catch", "catch_paa", "index_paa", "Ecov_obs", "obsvec")
# Set seed for reproducibility
set.seed(seed)
cat("\nNow simulating data for year ", y, "\n")
# Simulate the population and observations
om_sim <- om$simulate(complete = TRUE)
# Update the simulated data in the operating model
om$input$data[obs_names] <- om_sim[obs_names]
# Update the parameters in the operating model
om$input$par[random] <- om_sim[random]
cat("\nNow projecting data for years after ", y, "\n")
# Fit the WHAM model without actually performing the fit (do.fit = FALSE)
om_TEST <- fit_wham(om$input, do.fit = FALSE, do.brps = do.brps, MakeADFun.silent = TRUE)
}
} else {
# Names of observation data to update
obs_names <- c("agg_indices", "agg_catch", "catch_paa", "index_paa", "Ecov_obs", "obsvec")
set.seed(seed)
om_sim = om$simulate(complete=TRUE) #resimulate the population and observations
om$input$data[obs_names] = om_sim[obs_names] #update any simulated data
om$input$par[random] = om_sim[random] #update any simulated random effects
cat("\nNow simulating data")
# reset the om
om_TEST <- fit_wham(om$input, do.fit = FALSE, do.brps = do.brps, MakeADFun.silent = TRUE)
}
return(om_TEST)
}
mod = loop_through_fn_TEST(om = om_with_data,
em_info = info,
random = random,
M_em = M,
sel_em = sel2,
NAA_re_em = NAA_re,
age_comp_em = "multinomial",
em.opt = list(separate.em = FALSE,
separate.em.type = 3,
do.move = FALSE,
est.move = FALSE),
assess_years = assess.years,
assess_interval = assess.interval,
base_years = base.years,
year.use = 20,
add.years = TRUE,
# add.years=TRUE: assessment will use 20 years of data from historical period + new years in the feedback period
seed = 123,
save.sdrep = TRUE,
save.last.em = TRUE,
do.retro = TRUE, # Perform retrospective analysis
do.osa = TRUE) # Perform OSA residual analysis
knitr::opts_chunk$set(echo = TRUE, cache = TRUE)
# TO DO: COPY SOURCE CODE (SPECIFICALLY THE LOOP THROUGH OM FXN) AND USE BROWSER() TO STEP THROUGH WHAT'S GIVING TROUBLE
# library(pak)
# library(devtools)
# pak::pkg_install("timjmiller/wham")
# devtools::install_github("lichengxue/whamMSE", dependencies=TRUE)
# devtools::install_github("NOAA-EDAB/ecodata", dependencies=TRUE, build = FALSE)
library(wham)
library(whamMSE)
library(ecodata)
library(dplyr)
write.dir <- "C:/Users/swulfing/Documents/GitHub/UMassD/YT_proj"
setwd(write.dir)
gb_dat <- read_asap3_dat("ASAPfiles_5.14Pull/GBK.DAT")
input <- prepare_wham_input(gb_dat)
year_start  <- 1  # starting year in the burn-in period
year_end    <- 20  # end year in the burn-in period
MSE_years   <- 3     # number of years in the feedback loop
# Note: no need to include MSE_years in simulation-estimation
info <- generate_basic_info(n_stocks = input$data$n_stocks,
n_regions = input$data$n_regions,
n_indices = input$data$n_indices,
n_fleets = input$data$n_fleets,
n_seasons = input$data$n_seasons,
base.years = year_start:year_end,
n_feedback_years = MSE_years,
life_history = "medium", # Not sure if we're keeping this
n_ages = input$data$n_ages)
# IF something is specifying age comp (which I'm not bc from vig) This could create a conflict when comparing to em
# FIX THIS CHUNK FIRST I THINK THAT WILL HELP ALL YOUR OTHER PROBS (but who even knows at this point lol)
# COMPARE DIMENSIONS OF OLD CATCH/INDEX/F INFO AND FORCE THOSE ONTO THESE
###### OLD CODE ######
#
#
# # These right now are based on defaults or life history. FIND ARGUMENT TO PROVIDE MYSELF
basic_info = info$basic_info # collect basic information TRY input$data$catch_paa OR AGG CATCH
catch_info = info$catch_info # collect fleet catch information
index_info = info$index_info # collect survey information
F_info = info$F # collect fishing information
###### END ######
basic_info_FIX <- list(
n_stocks = 1L,
n_seasons = 1L,
n_fleets = 1L,
ages = 1:input$data$n_ages,
n_fleets = input$data$n_fleets,
fracyr_SSB = cbind(input$data$fracyr_SSB), #(n_years x n_stocks)
maturity = input$data$mature, #(n_stocks x n_years x n_ages)
years = as.integer(input$years), #(n_years)
waa = input$data$waa, #(any no. x n_years x n_ages)
waa_pointer_ssb = input$data$waa_pointer_ssb, #(n_stocks)
spawn_regions = 1, #(n_stocks)
spawn_seasons = 1 #(n_stocks)
)
basic_info$ages <-            basic_info_FIX$ages
basic_info$n_fleets <-        basic_info_FIX$n_fleets
basic_info$fracyr_SSB <-      basic_info_FIX$fracyr_SSB
basic_info$maturity <-        basic_info_FIX$maturity
basic_info$years <-           basic_info_FIX$years
basic_info$waa <-             basic_info_FIX$waa
basic_info$waa_pointer_ssb <- basic_info_FIX$waa_pointer_ssb
basic_info$waa_pointer_indices <- input[["data"]][["waa_pointer_indices"]]
basic_info$waa_pointer_M <- input$data$waa_pointer_M
catch_info_FIX <- list(
n_fleets = NCOL(input$data$agg_catch), #(n_fleets)
agg_catch = cbind(input$data$agg_catch), #(n_years x n_fleets)
agg_catch_cv = cbind(sqrt(exp(input$data$agg_catch_sigma^2) - 1)), #(n_years x n_fleets)
catch_paa = input$data$catch_paa, #(n_fleets x n_years x n_ages)
use_catch_paa = cbind(input$data$use_catch_paa), #(n_years x n_fleets), 0: don't use, 1: use
catch_Neff = cbind(input$data$catch_Neff), #(n_years x n_fleets)
selblock_pointer_fleets = cbind(input$data$selblock_pointer_fleets), #(n_years x n_fleets)
waa_pointer_fleets = input$data$waa_pointer_fleets, #(n_fleets)
fleet_regions = rep(1,input$data$n_fleets) #(n_fleets)
)
catch_info$n_fleets <-      catch_info_FIX$n_fleets
catch_info$agg_catch <-     catch_info_FIX$agg_catch
catch_info$agg_catch_cv <-  catch_info_FIX$agg_catch_cv#[1] #NOTE: THIS DIMENSION IS CHANGED FROM THE OG INPUT
catch_info$catch_paa <-     catch_info_FIX$catch_paa
catch_info$use_catch_paa <- catch_info_FIX$use_catch_paa
catch_info$catch_Neff <-    catch_info_FIX$catch_Neff
catch_info$selblock_pointer_fleets <- catch_info_FIX$selblock_pointer_fleets
catch_info$fleet_regions <- catch_info_FIX$fleet_regions
index_info_FIX <- list(
n_indices = NCOL(input$data$agg_indices),
agg_indices = cbind(input$data$agg_indices), #(n_years x n_indices)
units_indices = input$data$units_indices, #(n_indices) 1: biomass 2: numbers
units_index_paa = input$data$units_index_paa, #(n_indices) 1: biomass 2: numbers
agg_index_cv = cbind(sqrt(exp(input$data$agg_index_sigma^2) - 1)), #(n_years x n_indices)
index_Neff = cbind(input$data$index_Neff), #(n_years x n_indices)
fracyr_indices = cbind(input$data$fracyr_indices), #(n_years x n_indices)
use_indices = cbind(input$data$use_indices), #(n_years x n_indices)
use_index_paa = cbind(input$data$use_index_paa),  #(n_years x n_indices)
index_paa = input$data$index_paa,  #(n_indices x n_years x n_ages)
selblock_pointer_indices = cbind(input$data$selblock_pointer_indices), #(n_years x n_indices)
waa_pointer_indices = input$data$waa_pointer_indices, #(n_indices)
index_regions = rep(1,input$data$n_indices)) #(n_indices)
## This doesn't matter apparently
# index_info_FIX$index_Neff <- replace(index_info_FIX$index_Neff, index_info_FIX$index_Neff == -999, NA)
index_info$n_indices <-       index_info_FIX$n_indices
index_info$agg_indices <-     index_info_FIX$agg_indices
index_info$units_indices <-   index_info_FIX$units_indices
index_info$units_index_paa <- index_info_FIX$units_index_paa
index_info$agg_index_cv <-    index_info_FIX$agg_index_cv
index_info$index_Neff <-      index_info_FIX$index_Neff # NOTE: SOME ENTRIES -999, CHANGED TO NAS
index_info$fracyr_indices <-  index_info_FIX$fracyr_indices
index_info$use_indices <-     index_info_FIX$use_indices
index_info$use_index_paa <-   index_info_FIX$use_index_paa
index_info$index_paa <-       index_info_FIX$index_paa
index_info$index_regions <-   index_info_FIX$index_regions
#initial values for annual fully-selected fishing mortality
F_info_FIX <- list(F = matrix(0.3, length(basic_info$years), catch_info$n_fleets)) #(n_years x n_fleets)
# NOTE: DO WE WANT TO TAKE AVERAGE OF ALEX'S M'S? I DONT THINK THOSE ARE FISHING M'S BUT CHECK
F_info$F <- F_info_FIX$F
n_stocks  <- as.integer(basic_info['n_stocks'])
n_regions <- as.integer(basic_info['n_regions'])
n_fleets  <- as.integer(basic_info['n_fleets'])
n_indices <- as.integer(basic_info['n_indices'])
n_ages    <- as.integer(basic_info['n_ages'])
# Selectivity Configuration - ALEX CODE
sel2=list(
model=c("age-specific",
"logistic","logistic","logistic"),
re = c("ar1_y","none","none","none"), #re = c("ar1_y","none","none","none"), use ar1 to est sel but later fixing all
initial_pars=list(
c(0.1,0.25,0.5,1,1,1), # Commercial fleet
c(2,0.3), # Spring NEFSC
c(2,0.3), # Fall NEFSC
c(2,0.3)), # DFO survey
fix_pars = list(
c(4:6), # Estimate param for each age
c(NULL), # bc logistic, these only estimate 2 params so just want to fix first one
c(NULL),
c(NULL))
)
# CHENG SELECTIVITY
# fleet_pars <- c(5,1)
# index_pars <- c(2,1)
# sel <- list(model=rep("logistic",n_fleets+n_indices),
#             initial_pars=c(rep(list(fleet_pars),n_fleets),rep(list(index_pars),n_indices)))
# M Configuration
M <- list(model="constant",initial_means=array(c(0.57, 0.33, 0.26, 0.23, 0.22, 0.22), dim = c(n_stocks,n_regions,n_ages)))
sigma        <- "rec+1"
re_cor       <- "iid"
ini.opt      <- "equilibrium"
sigma_vals   <-  array(0.5, dim = c(n_stocks, n_regions, n_ages)) # NAA sigma
# NAA config
NAA_re <- list(N1_model=rep(ini.opt,n_stocks),
sigma=rep(sigma,n_stocks),
cor=rep(re_cor,n_stocks),
recruit_model = 3,  # rChanged from ALEX code
sigma_vals = sigma_vals) # NAA_where must be specified in basic_info!
input_NoEcov <- prepare_wham_input(basic_info = basic_info,
selectivity = sel2,
M = M,
NAA_re = NAA_re,
catch_info = catch_info,
index_info = index_info,
F = F_info,
age_comp = "logistic-normal-pool0")
# input_NoEcov[["data"]][["index_Neff"]] # Should I be making these NAs or 0?
# input_NoEcov[["data"]][["Ecov_obs"]]
random = input_NoEcov$random # check what processes are random effects
input_NoEcov$random = NULL # so inner optimization won't change simulated RE
### USE THIS OM WHEN DIAGNOSING ISSUES ###
# om <- fit_wham(input_NoEcov, do.fit = T, do.brps = T, MakeADFun.silent = TRUE,
#                do.retro = TRUE, do.osa = FALSE) #Changing do.retro and do.osa as per SGaichas email
### END ###
om <- fit_wham(input, do.fit = F, do.brps = T, MakeADFun.silent = TRUE)
# Note: do.fit must be FALSE (no modeling fitting yet)
# plot_wham_output(om)
###### DOING THIS CAUSES NAS TO BE PRODUCED ######
# input_NoEcov$par$mean_rec_pars[,1]<-c(mean(om$rep$log_SR_a)) # TOOK OUT SUBSCRIPTS FROM OG CODE
# input_NoEcov$par$mean_rec_pars[,2]<-c(mean(om$rep$log_SR_b))
#
# om_fix <- fit_wham(input_NoEcov, do.fit = T, do.brps = T, MakeADFun.silent = TRUE, do.retro = FALSE, do.osa = FALSE)
#
# check_convergence(om_fix)
######      ######
# input_NoEcov$par <- om$parList
# om_improve <- fit_wham(input_NoEcov, do.fit = T, do.brps = T, MakeADFun.silent = TRUE,
#                do.retro = TRUE, do.osa = FALSE)
#
om_with_data <- update_om_fn(om, seed = 123, random = random)
### END
assess.interval <- 3 # Note: assessment interval is 3 years, given the feedback period is 3 years, there will be only 1 assessment
base.years      <- year_start:year_end # Burn-in period
first.year      <- head(base.years,1)
terminal.year   <- tail(base.years,1)
assess.years    <- seq(terminal.year, tail(om$years,1)-assess.interval,by = assess.interval)
mod = loop_through_fn_TEST(om = om_with_data,
em_info = info,
random = random,
M_em = M,
sel_em = sel2,
NAA_re_em = NAA_re,
age_comp_em = "multinomial",
em.opt = list(separate.em = FALSE,
separate.em.type = 3,
do.move = FALSE,
est.move = FALSE),
assess_years = assess.years,
assess_interval = assess.interval,
base_years = base.years,
year.use = 20,
add.years = TRUE,
# add.years=TRUE: assessment will use 20 years of data from historical period + new years in the feedback period
seed = 123,
save.sdrep = TRUE,
save.last.em = TRUE,
do.retro = TRUE, # Perform retrospective analysis
do.osa = TRUE) # Perform OSA residual analysis
interval.info
# Iterative update F in the OM using get_F_from_Catch_TEST_region function
t <- 0
for (y in interval.info$years) {
year <- which(om$years == y)
t <- t + 1
Catch = interval.info$catch[t,]
rep <- om$rep #generate the reported values given the parameters
cat("\nNow calculating fleet-specific F in year ", y, "\n")
Fsolve <- get_F_from_Catch_TEST(om, Catch, year, method = "nlminb", by_fleet = by_fleet)
cat("\nFishing mortality is ", Fsolve, "\n")
cat("\nNow updating F in OM for year ", y, "\n")
om <- update_om_F(om, year, Fsolve)
# Names of observation data to update
obs_names <- c("agg_indices", "agg_catch", "catch_paa", "index_paa", "Ecov_obs", "obsvec")
# Set seed for reproducibility
set.seed(seed)
cat("\nNow simulating data for year ", y, "\n")
# Simulate the population and observations
om_sim <- om$simulate(complete = TRUE)
# Update the simulated data in the operating model
om$input$data[obs_names] <- om_sim[obs_names]
# Update the parameters in the operating model
om$input$par[random] <- om_sim[random]
cat("\nNow projecting data for years after ", y, "\n")
# Fit the WHAM model without actually performing the fit (do.fit = FALSE)
om_TEST <- fit_wham(om$input, do.fit = FALSE, do.brps = do.brps, MakeADFun.silent = TRUE)
}
remove.package("whamMSE")
source("C:/Users/swulfing/Documents/GitHub/UMassD/YT_proj/GBK_No_feedback.R", echo=TRUE)
remove.packages("whamMSE")
devtools::install_github("lichengxue/whamMSE", dependencies=TRUE)
remove.packages("whamMSE")
