return(res)
# #end function evaluate()
}
# Fixed 10% exploitation rate of est. biomass for all iterations and 20 yrs
project.fixed <- evaluate(pars.iter, biomass.iter, control.pars, data.years,
proj.years, niter, overshoot = NA)
tail(project.fixed)
# View trajectories of catch and om biomass from output
projection.plot <- function(project.results) {
# Fig2 <- ggplot(data = subset(project.results, type != "index"),
#  aes(x = year, y = value))
project.results %>%
filter(type %in% c("biomass","catch")) %>%
group_by(type, year) %>%
median_qi(value, .width = c(.5, .8, .95)) %>%
ggplot() +
geom_lineribbon(aes(x = year, y = value, ymin = .lower, ymax = .upper),
show.legend = FALSE) +
scale_fill_brewer() +
geom_line(aes(y=value,x=year),data = subset(project.results, type != "index" & iter==1 & year %in% proj.years), lty=1,lwd=1,col=gray(0.7)) +
geom_line(aes(y=value,x=year),data = subset(project.results, type != "index" & iter==2 & year %in% proj.years), lty=1,lwd=1,col=gray(0.7)) +
geom_line(aes(y=value,x=year),data = subset(project.results, type != "index" & iter==3 & year %in% proj.years), lty=1,lwd=1,col=gray(0.7)) +
# stat_summary(fun.data = "median_hilow", geom = "smooth", col="black",
#              fill = gray(0.5), lty = 2, aes=0.1) +
# stat_summary(fun = median, fun.min = function(x)0, geom="line",
#              data = subset(project.results, type != "index" & year %in% data.years), lwd=1) +
facet_wrap(~type, scale = "free_y") +
ylab("Million tonnes") +
theme_bw()
}
projection.plot(project.fixed)
knitr::opts_chunk$set(echo = FALSE)
library(tidyverse)
library(ggdist)
library(Hmisc)
library(mvtnorm)
library(here)
write.dir <- "C:/Users/swulfing/OneDrive - University of Massachusetts Dartmouth/Documents/GitHub/UMassD/YT_proj"
setwd(write.dir)
gb_dat <- read_asap3_dat(here("YT_proj/ASAPfiles_5.14Pull/GBK.DAT"))
harvest <- gb_dat[[1]][["dat"]][["CAA_mats"]][[1]]
gb_dat <- read_asap3_dat(here("YT_proj/ASAPfiles_5.14Pull/GBK.DAT"))
library(wham)
gb_dat <- read_asap3_dat(here("YT_proj/ASAPfiles_5.14Pull/GBK.DAT"))
data.years <- gb_dat[[1]]$dat$year1:(gb_dat[[1]]$dat$year1 + gb_dat[[1]]$dat$n_years)
harvest <- gb_dat[[1]][["dat"]][["CAA_mats"]][[1]]
harvest
View(harvest)
harvest <- rowSums(gb_dat[[1]][["dat"]][["CAA_mats"]][[1]])
index <- gb_dat[[1]][["dat"]][["index_month"]]
index
harvest <- c(0.1,3,15,52,76,139,95,93,84,93,86,103,104,
92,46,67,59,30,54,59,47,33,44)
index <- c(NA,NA,NA,NA,NA,NA,NA,NA,935,NA,1057,NA,678,NA,
420,NA,554,NA,458,NA,474,NA,280)
length(harvest)
length(Indometh)
length(index)
Indometh
index <- gb_dat[[1]][["dat"]][["prop_rel_mats"]]
View(index)
index <- gb_dat[[1]][["dat"]][["prop_rel_mats"]][[1]]
gb_dat[[1]][["dat"]][["index_units"]]
input <- prepare_wham_input(gb_dat)
View(input)
index_info <- list(
n_indices = NCOL(input$data$agg_indices),
agg_indices = cbind(input$data$agg_indices), #(n_years x n_indices)
units_indices = input$data$units_indices, #(n_indices) 1: biomass 2: numbers
units_index_paa = input$data$units_index_paa, #(n_indices) 1: biomass 2: numbers
agg_index_cv = cbind(sqrt(exp(input$data$agg_index_sigma^2) - 1)), #(n_years x n_indices)
index_Neff = cbind(input$data$index_Neff), #(n_years x n_indices)
fracyr_indices = cbind(input$data$fracyr_indices), #(n_years x n_indices)
use_indices = cbind(input$data$use_indices), #(n_years x n_indices)
use_index_paa = cbind(input$data$use_index_paa),  #(n_years x n_indices)
index_paa = input$data$index_paa,  #(n_indices x n_years x n_ages)
selblock_pointer_indices = cbind(input$data$selblock_pointer_indices), #(n_years x n_indices)
waa_pointer_indices = input$data$waa_pointer_indices, #(n_indices)
index_regions = rep(1,input$data$n_indices)) #(n_indices)
View(index_info)
index <- input$data$units_indices
index
install.packages("TMB")
View(gb_dat[[1]][["dat"]][["IAA_mats"]][[1]])
knitr::opts_chunk$set(echo = FALSE)
library(wham)
library(tidyverse)
library(ggdist)
library(Hmisc)
library(mvtnorm)
library(here)
write.dir <- "C:/Users/swulfing/OneDrive - University of Massachusetts Dartmouth/Documents/GitHub/UMassD/YT_proj"
setwd(write.dir)
gb_dat <- read_asap3_dat(here("YT_proj/ASAPfiles_5.14Pull/GBK.DAT"))
input <- prepare_wham_input(gb_dat)
index <- gb_dat[[1]][["dat"]][["IAA_mats"]][[1]]
View(index)
index[,-1]
plot(data.years,index, pch=19,xlab="Year",ylab="Million tonnes (B/C)")
length(data.years)
length(harvest)
gb_dat[[1]][["dat"]][["CAA_mats"]][[1]]
length(data.years)
nrow(gb_dat[[1]][["dat"]][["CAA_mats"]][[1]])
harvest
harvest <- rowSums(gb_dat[[1]][["dat"]][["CAA_mats"]][[1]])
harvest
plot(data.years,index, pch=19,xlab="Year",ylab="Million tonnes (B/C)")
lines(data.years,harvest,lty=2,lwd=2)
data.years <- gb_dat[[1]]$dat$year1:(gb_dat[[1]]$dat$year1 + gb_dat[[1]]$dat$n_years-1)
plot(data.years,index, pch=19,xlab="Year",ylab="Million tonnes (B/C)")
length(index)
#NOTE: ONLY USING INDEX 1 AND ADDING ACROSS COLUMNS. NOT SURE IF THAT'S RIGHT BUT I'M JUST GOING TO DO IT FOR NOW
index <- gb_dat[[1]][["dat"]][["IAA_mats"]][[1]]
index <- rowSums(index[,-1])
plot(data.years,index, pch=19,xlab="Year",ylab="Million tonnes (B/C)")
lines(data.years,harvest,lty=2,lwd=2)
plot(data.years,index, pch=19,xlab="Year",ylab="Million tonnes (B/C)")
lines(data.years,harvest,lty=2,lwd=2)
length(gb_dat[[1]][["dat"]][["IAA_mats"]])
index_all <- list()
#NOTE: IM JUST ADDING ALL THE INDICES TOGETHER. NO IDEA IF IM SUPPOSED TO DO THAT
for(i in 1:length(gb_dat[[1]][["dat"]][["IAA_mats"]])){
index_fill <- gb_dat[[1]][["dat"]][["IAA_mats"]][[i]]
index_fill <- rowSums(index_fill[,-1])
index_all[,i] <- index_fill
}
index_all <- matrix()
#NOTE: IM JUST ADDING ALL THE INDICES TOGETHER. NO IDEA IF IM SUPPOSED TO DO THAT
for(i in 1:length(gb_dat[[1]][["dat"]][["IAA_mats"]])){
index_fill <- gb_dat[[1]][["dat"]][["IAA_mats"]][[i]]
index_fill <- rowSums(index_fill[,-1])
index_all[,i] <- index_fill
}
index_all <- matrix(, nrow = 88)
#NOTE: IM JUST ADDING ALL THE INDICES TOGETHER. NO IDEA IF IM SUPPOSED TO DO THAT
for(i in 1:length(gb_dat[[1]][["dat"]][["IAA_mats"]])){
index_fill <- gb_dat[[1]][["dat"]][["IAA_mats"]][[i]]
index_fill <- rowSums(index_fill[,-1])
index_all[,i] <- index_fill
}
index_all <- matrix(, nrow = 88, ncol = 7)
#NOTE: IM JUST ADDING ALL THE INDICES TOGETHER. NO IDEA IF IM SUPPOSED TO DO THAT
for(i in 1:length(gb_dat[[1]][["dat"]][["IAA_mats"]])){
index_fill <- gb_dat[[1]][["dat"]][["IAA_mats"]][[i]]
index_fill <- rowSums(index_fill[,-1])
index_all[,i] <- index_fill
}
index_all
index <- rowSums(index_all)
plot(data.years,index_all, pch=19,xlab="Year",ylab="Million tonnes (B/C)")
length(index)
length(data.years)
length(harvest)
length(index_all)
plot(data.years,index, pch=19,xlab="Year",ylab="Million tonnes (B/C)")
plot(data.years,index, pch=19,xlab="Year",ylab="Million tonnes (B/C)")
lines(data.years,harvest,lty=2,lwd=2)
# Logistic Production
schaefer <- function(B,C,K,r) {
#function schaefer takes the current biomass, a catch,
#and the model parameters to compute next year's biomass
res <- B + B * r * (1 - B/K) - C
return(max(0.001,res)) # we add a constraint to prevent negative biomass
}
# Biomass Projection
dynamics <- function(pars,C,yrs) {
# dynamics takes the model parameters, the time series of catch,
# & the yrs to do the projection over
# first extract the parameters from the pars vector (we estimate K in log-space)
K <- exp(pars[1])
r <- exp(pars[2])
# find the total number of years
nyr <- length(C) + 1
# if the vector of years was not supplied we create
# a default to stop the program crashing
if (missing(yrs)) yrs <- 1:nyr
#set up the biomass vector
B <- numeric(nyr)
#intialize biomass at carrying capacity
B[1] <- K
# project the model forward using the schaefer model
for (y in 2:nyr) {
B[y] <- schaefer(B[y-1],C[y-1],K,r)
}
#return the time series of biomass
return(B[yrs])
#end function dynamics
}
# function to calculate the negative log-likelihood
nll <- function(pars,C,U) { #this function takes the parameters, the catches, and the index data
sigma <- exp(pars[3]) # additional parameter, the standard deviation of the observation error
B <- dynamics(pars,C) #run the biomass dynamics for this set of parameters
Uhat <- B #calculate the predicted biomass index - here we assume an unbiased absolute biomass estimate
output <- -sum(dnorm(log(U),log(Uhat),sigma,log=TRUE),na.rm=TRUE) #calculate the negative log-likelihood
return(output)
#end function nll
}
assess <- function(catch,index,calc.vcov=FALSE,pars.init) {
# assess takes catch and index data, initial values for the parameters,
# and a flag saying whether to compute uncertainty estimates for the model parameters
#fit model
# optim runs the function nll() repeatedly with differnt values for the parameters,
# to find the values that give the best fit to the index data
res <- optim(pars.init,nll,C=catch,U=index,hessian=TRUE)
# store the output from the model fit
output <- list()
output$pars <- res$par
output$biomass <- dynamics(res$par,catch)
output$convergence <- res$convergence
output$nll <- res$value
if (calc.vcov)
output$vcov <- solve(res$hessian)
return(output)
#end function assess
}
ini.parms <- c(log(1200), log(0.1), log(0.3))
redfish <- assess(harvest,index,calc.vcov=TRUE,ini.parms)
ini.parms <- c(log(12000), log(0.1), log(0.3)) # log(K), log(r), log(sigma)
redfish <- assess(harvest,index,calc.vcov=TRUE,ini.parms)
data.years <- gb_dat[[1]]$dat$year1:(gb_dat[[1]]$dat$year1 + gb_dat[[1]]$dat$n_years-1)
harvest <- rowSums(gb_dat[[1]][["dat"]][["CAA_mats"]][[1]])
index_all <- matrix(, nrow = 88, ncol = 7)
#NOTE: IM JUST ADDING ALL THE INDICES TOGETHER. NO IDEA IF IM SUPPOSED TO DO THAT
for(i in 1:length(gb_dat[[1]][["dat"]][["IAA_mats"]])){
index_fill <- gb_dat[[1]][["dat"]][["IAA_mats"]][[i]]
index_fill <- rowSums(index_fill[,-1])
index_all[,i] <- index_fill
}
index <- rowSums(index_all)
plot(data.years,index, pch=19,xlab="Year",ylab="Million tonnes (B/C)")
lines(data.years,harvest,lty=2,lwd=2)
ini.parms <- c(log(700), log(0.1), log(0.3)) # log(K), log(r), log(sigma)
redfish <- assess(harvest,index,calc.vcov=TRUE,ini.parms)
plot(data.years,index, pch=19,xlab="Year",ylab="Million tonnes (B/C)", ylim = c(0,1000))
plot(data.years,index, pch=19,xlab="Year",ylab="Million tonnes (B/C)", ylim = c(0,1000))
lines(data.years,harvest,lty=2,lwd=2)
plot(data.years,index, pch=19,xlab="Year", ylim = c(0,2000))
plot(data.years,index, pch=19,xlab="Year", ylim = c(0,2000)) +
lines(data.years,harvest,lty=2,lwd=2)
plot(data.years,index, pch=19,xlab="Year", ylim = c(0,20000)) +
lines(data.years,harvest,lty=2,lwd=2)
ini.parms <- c(log(20000), log(0.1), log(0.3)) # log(K), log(r), log(sigma)
redfish <- assess(harvest,index,calc.vcov=TRUE,ini.parms)
plot(data.years,index, pch=19,xlab="Year", ylim = c(0,30000)) +
lines(data.years,harvest,lty=2,lwd=2)
plot(data.years,index, pch=19,xlab="Year", ylim = c(0,40000)) +
lines(data.years,harvest,lty=2,lwd=2)
ini.parms <- c(log(40000), log(0.1), log(0.3)) # log(K), log(r), log(sigma)
redfish <- assess(harvest,index,calc.vcov=TRUE,ini.parms)
plot(data.years,index, pch=19,xlab="Year", ylim = c(0,50000)) +
lines(data.years,harvest,lty=2,lwd=2)
plot(data.years,index, pch=19,xlab="Year", ylim = c(0,max(harvest))) +
lines(data.years,harvest,lty=2,lwd=2)
ini.parms <- c(log(60000), log(0.1), log(0.3)) # log(K), log(r), log(sigma)
redfish <- assess(harvest,index,calc.vcov=TRUE,ini.parms)
ini.parms <- c(log(0.1), log(0.1), log(0.3)) # log(K), log(r), log(sigma)
redfish <- assess(harvest,index,calc.vcov=TRUE,ini.parms)
plot(data.years,index, pch=19,xlab="Year") + #, ylim = c(0,max(harvest))) +
lines(data.years,harvest,lty=2,lwd=2)
ini.parms <- c(log(700), log(0.1), log(0.3)) # log(K), log(r), log(sigma)
redfish <- assess(harvest,index,calc.vcov=TRUE,ini.parms)
ini.parms <- c(log(700), log(0.1), log(3)) # log(K), log(r), log(sigma)
redfish <- assess(harvest,index,calc.vcov=TRUE,ini.parms)
ini.parms <- c(log(700), log(1), log(3)) # log(K), log(r), log(sigma)
redfish <- assess(harvest,index,calc.vcov=TRUE,ini.parms)
ini.parms <- c(log(700), log(3), log(3)) # log(K), log(r), log(sigma)
redfish <- assess(harvest,index,calc.vcov=TRUE,ini.parms)
ini.parms <- c(log(1200), log(3), log(0.3)) # log(K), log(r), log(sigma)
redfish <- assess(harvest,index,calc.vcov=TRUE,ini.parms)
ini.parms <- c(log(1200), log(3), log(3)) # log(K), log(r), log(sigma)
redfish <- assess(harvest,index,calc.vcov=TRUE,ini.parms)
ini.parms <- c(log(700000), log(0.1), log(0.3)) # log(K), log(r), log(sigma)
redfish <- assess(harvest,index,calc.vcov=TRUE,ini.parms)
ini.parms <- c(log(700), log(0.1), log(0.9)) # log(K), log(r), log(sigma)
redfish <- assess(harvest,index,calc.vcov=TRUE,ini.parms)
ini.parms <- c(log(700), log(0.1), log(0.1)) # log(K), log(r), log(sigma)
redfish <- assess(harvest,index,calc.vcov=TRUE,ini.parms)
ini.parms <- c(log(700), log(0.1), log(10)) # log(K), log(r), log(sigma)
redfish <- assess(harvest,index,calc.vcov=TRUE,ini.parms)
ini.parms <- c(log(0.1), log(0.1), log(0.3)) # log(K), log(r), log(sigma)
redfish <- assess(harvest,index,calc.vcov=TRUE,ini.parms)
ini.parms <- c(log(0.3), log(0.1), log(0.3)) # log(K), log(r), log(sigma)
redfish <- assess(harvest,index,calc.vcov=TRUE,ini.parms)
ini.parms <- c(log(1200), log(1.1), log(0.3)) # log(K), log(r), log(sigma)
redfish <- assess(harvest,index,calc.vcov=TRUE,ini.parms)
ini.parms <- c(log(1200), log(1.1), log(0.3)) # log(K), log(r), log(sigma)
redfish <- assess(harvest,index,calc.vcov=TRUE,ini.parms)
ini.parms <- c(log(1200), log(10), log(0.3)) # log(K), log(r), log(sigma)
redfish <- assess(harvest,index,calc.vcov=TRUE,ini.parms)
pars.init <- ini.parms
catch <- harvest
calc.vcov = TRUE
# assess takes catch and index data, initial values for the parameters,
# and a flag saying whether to compute uncertainty estimates for the model parameters
#fit model
# optim runs the function nll() repeatedly with differnt values for the parameters,
# to find the values that give the best fit to the index data
res <- optim(pars.init,nll,C=catch,U=index,hessian=TRUE)
C=catch
U=index
hessian=TRUE
sigma <- exp(pars[3]) # additional parameter, the standard deviation of the observation error
pars <- pars.init
sigma <- exp(pars[3]) # additional parameter, the standard deviation of the observation error
B <- dynamics(pars,C) #run the biomass dynamics for this set of parameters
Uhat <- B #calculate the predicted biomass index - here we assume an unbiased absolute biomass estimate
output <- -sum(dnorm(log(U),log(Uhat),sigma,log=TRUE),na.rm=TRUE) #calculate the negative log-likelihood
output
pars
pars[3]
exp(pars[3])
B <- dynamics(pars,C) #run the biomass dynamics for this set of parameters
B
Uhat <- B #calculate the predicted biomass index - here we assume an unbiased absolute biomass estimate
dnorm(log(U),log(Uhat),sigma,log=TRUE)
U
index
View(gb_dat[[1]][["dat"]][["IAA_mats"]])
gb_dat[[1]][["dat"]][["IAA_mats"]][[1]]
gb_dat[[1]][["dat"]][["IAA_mats"]][[2]]
gb_dat[[1]][["dat"]][["IAA_mats"]][[3]]
index_all <- matrix(, nrow = 88, ncol = 7)
#NOTE: IM JUST ADDING ALL THE INDICES TOGETHER. NO IDEA IF IM SUPPOSED TO DO THAT
for(i in 1:length(gb_dat[[1]][["dat"]][["IAA_mats"]])){
index_fill <- gb_dat[[1]][["dat"]][["IAA_mats"]][[i]]
index_fill <- rowSums(index_fill[-c(1:28),-1])
index_all[,i] <- index_fill
}
index_all <- matrix(, nrow = (88 - 28), ncol = 7)
#NOTE: IM JUST ADDING ALL THE INDICES TOGETHER. NO IDEA IF IM SUPPOSED TO DO THAT
for(i in 1:length(gb_dat[[1]][["dat"]][["IAA_mats"]])){
index_fill <- gb_dat[[1]][["dat"]][["IAA_mats"]][[i]]
index_fill <- rowSums(index_fill[-c(1:28),-1])
index_all[,i] <- index_fill
}
data.years <- (gb_dat[[1]]$dat$year1 + 28):(gb_dat[[1]]$dat$year1 + gb_dat[[1]]$dat$n_years-1)
data.years
harvest <- harvest[-c(1:28)]
harvest
data.years <- (gb_dat[[1]]$dat$year1 + 28):(gb_dat[[1]]$dat$year1 + gb_dat[[1]]$dat$n_years-1)
harvest <- rowSums(gb_dat[[1]][["dat"]][["CAA_mats"]][[1]])
harvest <- harvest[-c(1:28)]
index_all <- matrix(, nrow = (88 - 28), ncol = 7)
#NOTE: IM JUST ADDING ALL THE INDICES TOGETHER. NO IDEA IF IM SUPPOSED TO DO THAT
for(i in 1:length(gb_dat[[1]][["dat"]][["IAA_mats"]])){
index_fill <- gb_dat[[1]][["dat"]][["IAA_mats"]][[i]]
index_fill <- rowSums(index_fill[-c(1:28),-1])
index_all[,i] <- index_fill
}
index <- rowSums(index_all)
plot(data.years,index, pch=19,xlab="Year") + #, ylim = c(0,max(harvest))) +
lines(data.years,harvest,lty=2,lwd=2)
# Logistic Production
schaefer <- function(B,C,K,r) {
#function schaefer takes the current biomass, a catch,
#and the model parameters to compute next year's biomass
res <- B + B * r * (1 - B/K) - C
return(max(0.001,res)) # we add a constraint to prevent negative biomass
}
# Biomass Projection
dynamics <- function(pars,C,yrs) {
# dynamics takes the model parameters, the time series of catch,
# & the yrs to do the projection over
# first extract the parameters from the pars vector (we estimate K in log-space)
K <- exp(pars[1])
r <- exp(pars[2])
# find the total number of years
nyr <- length(C) + 1
# if the vector of years was not supplied we create
# a default to stop the program crashing
if (missing(yrs)) yrs <- 1:nyr
#set up the biomass vector
B <- numeric(nyr)
#intialize biomass at carrying capacity
B[1] <- K
# project the model forward using the schaefer model
for (y in 2:nyr) {
B[y] <- schaefer(B[y-1],C[y-1],K,r)
}
#return the time series of biomass
return(B[yrs])
#end function dynamics
}
# function to calculate the negative log-likelihood
nll <- function(pars,C,U) { #this function takes the parameters, the catches, and the index data
sigma <- exp(pars[3]) # additional parameter, the standard deviation of the observation error
B <- dynamics(pars,C) #run the biomass dynamics for this set of parameters
Uhat <- B #calculate the predicted biomass index - here we assume an unbiased absolute biomass estimate
output <- -sum(dnorm(log(U),log(Uhat),sigma,log=TRUE),na.rm=TRUE) #calculate the negative log-likelihood
return(output)
#end function nll
}
assess <- function(catch,index,calc.vcov=FALSE,pars.init) {
# assess takes catch and index data, initial values for the parameters,
# and a flag saying whether to compute uncertainty estimates for the model parameters
#fit model
# optim runs the function nll() repeatedly with differnt values for the parameters,
# to find the values that give the best fit to the index data
res <- optim(pars.init,nll,C=catch,U=index,hessian=TRUE)
# store the output from the model fit
output <- list()
output$pars <- res$par
output$biomass <- dynamics(res$par,catch)
output$convergence <- res$convergence
output$nll <- res$value
if (calc.vcov)
output$vcov <- solve(res$hessian)
return(output)
#end function assess
}
knitr::opts_chunk$set(echo = FALSE)
library(wham)
library(tidyverse)
library(ggdist)
library(Hmisc)
library(mvtnorm)
library(here)
write.dir <- "C:/Users/swulfing/OneDrive - University of Massachusetts Dartmouth/Documents/GitHub/UMassD/YT_proj"
setwd(write.dir)
gb_dat <- read_asap3_dat(here("YT_proj/ASAPfiles_5.14Pull/GBK.DAT"))
input <- prepare_wham_input(gb_dat)
data.years <- (gb_dat[[1]]$dat$year1 + 28):(gb_dat[[1]]$dat$year1 + gb_dat[[1]]$dat$n_years-1)
harvest <- rowSums(gb_dat[[1]][["dat"]][["CAA_mats"]][[1]])
harvest <- harvest[-c(1:28)]
index_all <- matrix(, nrow = (88 - 28), ncol = 7)
#NOTE: IM JUST ADDING ALL THE INDICES TOGETHER. NO IDEA IF IM SUPPOSED TO DO THAT
for(i in 1:length(gb_dat[[1]][["dat"]][["IAA_mats"]])){
index_fill <- gb_dat[[1]][["dat"]][["IAA_mats"]][[i]]
index_fill <- rowSums(index_fill[-c(1:28),-1])
index_all[,i] <- index_fill
}
index <- rowSums(index_all)
plot(data.years,index, pch=19,xlab="Year") + #, ylim = c(0,max(harvest))) +
lines(data.years,harvest,lty=2,lwd=2)
# NOTE: IVE DELETED THE FIREST 28 YEARS OF DATA BECUASE THE AGGREGATED INDICES WERE 0 UNTIL 1963 AND THIS WAS GIVING ME PROBLEMS WHEN OPTIMIZING.
data.years <- (gb_dat[[1]]$dat$year1 + 28):(gb_dat[[1]]$dat$year1 + gb_dat[[1]]$dat$n_years-1)
harvest <- rowSums(gb_dat[[1]][["dat"]][["CAA_mats"]][[1]])
harvest <- harvest[-c(1:28)]
index_all <- matrix(, nrow = (88 - 28), ncol = 7)
#NOTE: IM JUST ADDING ALL THE INDICES TOGETHER. NO IDEA IF IM SUPPOSED TO DO THAT
for(i in 1:length(gb_dat[[1]][["dat"]][["IAA_mats"]])){
index_fill <- gb_dat[[1]][["dat"]][["IAA_mats"]][[i]]
index_fill <- rowSums(index_fill[-c(1:28),-1])
index_all[,i] <- index_fill
}
index <- rowSums(index_all)
plot(data.years,index, pch=19,xlab="Year") + #, ylim = c(0,max(harvest))) +
lines(data.years,harvest,lty=2,lwd=2)
# Logistic Production
schaefer <- function(B,C,K,r) {
#function schaefer takes the current biomass, a catch,
#and the model parameters to compute next year's biomass
res <- B + B * r * (1 - B/K) - C
return(max(0.001,res)) # we add a constraint to prevent negative biomass
}
# Biomass Projection
dynamics <- function(pars,C,yrs) {
# dynamics takes the model parameters, the time series of catch,
# & the yrs to do the projection over
# first extract the parameters from the pars vector (we estimate K in log-space)
K <- exp(pars[1])
r <- exp(pars[2])
# find the total number of years
nyr <- length(C) + 1
# if the vector of years was not supplied we create
# a default to stop the program crashing
if (missing(yrs)) yrs <- 1:nyr
#set up the biomass vector
B <- numeric(nyr)
#intialize biomass at carrying capacity
B[1] <- K
# project the model forward using the schaefer model
for (y in 2:nyr) {
B[y] <- schaefer(B[y-1],C[y-1],K,r)
}
#return the time series of biomass
return(B[yrs])
#end function dynamics
}
# function to calculate the negative log-likelihood
nll <- function(pars,C,U) { #this function takes the parameters, the catches, and the index data
sigma <- exp(pars[3]) # additional parameter, the standard deviation of the observation error
B <- dynamics(pars,C) #run the biomass dynamics for this set of parameters
Uhat <- B #calculate the predicted biomass index - here we assume an unbiased absolute biomass estimate
output <- -sum(dnorm(log(U),log(Uhat),sigma,log=TRUE),na.rm=TRUE) #calculate the negative log-likelihood
return(output)
#end function nll
}
assess <- function(catch,index,calc.vcov=FALSE,pars.init) {
# assess takes catch and index data, initial values for the parameters,
# and a flag saying whether to compute uncertainty estimates for the model parameters
#fit model
# optim runs the function nll() repeatedly with differnt values for the parameters,
# to find the values that give the best fit to the index data
res <- optim(pars.init,nll,C=catch,U=index,hessian=TRUE)
# store the output from the model fit
output <- list()
output$pars <- res$par
output$biomass <- dynamics(res$par,catch)
output$convergence <- res$convergence
output$nll <- res$value
if (calc.vcov)
output$vcov <- solve(res$hessian)
return(output)
#end function assess
}
ini.parms <- c(log(1200), log(0.1), log(0.3)) # log(K), log(r), log(sigma)
redfish <- assess(harvest,index,calc.vcov=TRUE,ini.parms)
ini.parms <- c(log(700), log(0.1), log(0.3)) # log(K), log(r), log(sigma)
redfish <- assess(harvest,index,calc.vcov=TRUE,ini.parms)
redfish
