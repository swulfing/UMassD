# devtools::install_github("lichengxue/whamMSE", dependencies=TRUE)
library(wham)
library(whamMSE)
library(dplyr)

setwd("C:/Users/swulfing/Documents/GitHub/UMassD/YT_proj")

gb_dat <- read_asap3_dat("ASAPfiles_5.14Pull/GBK.DAT")
input <- prepare_wham_input(gb_dat)

## Set number of years in the OM

# We need to match the years from GBK.DAT
input$years # check years 
year_start <- 1973
year_end   <- 2022
MSE_years  <- 0    # number of years in the feedback loop 

## Set Maturity at age (MAA)

input$data$mature[,1,] # MAA is constant over years, just extract one MAA from a year. NEED 6 FOR 6 AGES
user_maturity = NULL
dim(input$data$mature)
user_maturity = array(NA, dim = c(1,50,6)) # WANT TO MATCH DIMENSIONS
user_maturity[,1:50,] = input$data$mature  # IM NOT ENTIRELY SURE WHY THIS WAS NECESSARY IT JUST RESULTS IN THE SAME DIMS
 
## Set Weight at age (WAA)

user_waa = NULL
dim(input$data$waa)
user_waa$waa = array(NA, dim = c(5,50,6))
user_waa$waa[,1:50,] = input$data$waa

# pointer is used to identify which waa is used for which fleet/catch/SSB
user_waa$waa_pointer_fleets = input$data$waa_pointer_fleets
user_waa$waa_pointer_indices = input$data$waa_pointer_indices
user_waa$waa_pointer_totcatch = input$data$waa_pointer_ssb # kind of 'required'... Tim used to have this but now he removed, so this won't affect any calculation, that's what I want to say
user_waa$waa_pointer_ssb = input$data$waa_pointer_ssb
user_waa$waa_pointer_M = input$data$waa_pointer_M

## Set `fracyr_SSB`

fracyr_spawn = gb_dat[[1]]$dat$fracyr_spawn # it's a constant value 0.4166667, this will be used to calculated fracyr_SSB in the input

## Set `catch_info`

catch_info = list() # require catch_cv, catch_Neff, use_agg_catch, use_catch_paa

catch_cv = 0.05 # sqrt(exp(input$data$agg_catch_sigma^2) - 1) is constant so only 1 value is needed here
use_agg_catch = 1 # input$data$use_agg_catch, constant, again one value is needed
use_catch_paa = 1 # cbind(input$data$use_catch_paa), constant, again one value is needed
catch_Neff = 50 # cbind(input$data$catch_Neff) constant, one value is needed

catch_info = list(catch_cv = catch_cv, 
                  catch_Neff = catch_Neff, 
                  use_agg_catch = use_agg_catch, 
                  use_catch_paa = use_catch_paa)


## Set `index_info`

index_info = list() # index_cv, index_Neff, fracyr_indices, q, use_indices, use_index_paa, units_indices, units_index_paa

# Index CV
sqrt(exp(input$data$agg_index_sigma^2) - 1) # Here we can see CV for agg. index is changing over years, it's safe to first set a constant value for all index CVs and then modify after generate_basic_info

index_cv = rep(0.5,3) # remember to change that later

# Index Neff
input$data$index_Neff # there are some -999, so, we can set 25 for all of the indices first and then change some of them to be -999 after the input is generated by the generate_basic_info() function

index_Neff = rep(25,3)

# Index units
input$data$units_indices # a constant value, so one single value is needed here

units_indices = rep(2,3)

# Index paa units
input$data$units_index_paa # again, 2, a single value will be used

units_index_paa = rep(2,3)

# fracyr_indices

input$data$fracyr_indices # it's time-invariant but different across indices, so we need a vector

fracyr_indices = c(0.25,0.75,0.25)

# use_indices and use_index_paa, you don't need to specify them since default is use = TRUE

# selblock_pointer_indices,  don't need to use it since there is no selectivity block

# waa_pointer_indices and index_regions, don't need 

# fracyr_indices

# Index catchabilities (q), you should specify q here in generate_basic_info, unless q is treated as a random effect!
q = rep(0.2,3) # I don't know q for each index, but you can check in the most recent stock assessment model, I here use 0.2 

# use_indices and use_index_paa
input$data$use_indices
use_indices = rep(1,3) # you can see where index_Neff has -999 is corresponding to 0 in use_indices, we here use 1 for all, but need to change some values back to 0 later!
input$data$use_index_paa
use_index_paa = rep(1,3) # you can see where index_Neff has -999 is corresponding to 0 in use_indices, we here use 1 for all, but need to change some values back to 0 later!

index_info = list(index_cv = index_cv, 
                  index_Neff = index_Neff, 
                  fracyr_indices = fracyr_indices, 
                  q = q, 
                  use_indices = use_indices, 
                  use_index_paa = use_index_paa, 
                  units_indices = units_indices, 
                  units_index_paa = units_index_paa)

# agg_indices and index_paa, 
input$data$agg_indices
input$data$index_paa

# It's done! Don't forget to change them later!

## Generate Basic Info!

info <- generate_basic_info(n_stocks = 1L,
                            n_regions = 1L,
                            n_indices = 3L,
                            n_fleets = 1L,
                            n_seasons = 1L,
                            base.years = year_start:year_end,
                            n_feedback_years = MSE_years,
                            n_ages = 6,
                            catch_info = catch_info,
                            index_info = index_info,
                            user_waa = user_waa, 
                            user_maturity = user_maturity,
                            fracyr_spawn = fracyr_spawn
) 

basic_info = info$basic_info # collect basic information
catch_info_use = info$catch_info # collect fleet catch information
index_info_use = info$index_info # collect survey information
F_info = info$F # collect fishing information

catch_info_use$agg_catch[1:50,] = input$data$agg_catch # FROM WHAT CHENG IS DOING I THINK LIKE HE SAID IT'S EASIER TO GENERATE BASIC INFO AND THEEEEEEEN CHANGE IT TO PUT IN REAL DATA (lines 144-15)
catch_info_use$catch_paa[,1:50,] = input$data$catch_paa
# 
index_info_use$agg_indices[1:50,] = input$data$agg_indices
index_info_use$index_paa[,1:50,] = input$data$index_paa
index_info_use$use_indices[1:50,] = input$data$use_indices
index_info_use$use_index_paa[1:50,] = input$data$use_index_paa

n_stocks  <- as.integer(basic_info['n_stocks'])
n_regions <- as.integer(basic_info['n_regions'])
n_fleets  <- as.integer(basic_info['n_fleets'])
n_indices <- as.integer(basic_info['n_indices'])
n_ages    <- as.integer(basic_info['n_ages'])

# Selectivity Configuration - ALEX CODE
sel2=list(
  model=c("age-specific",
          "logistic","logistic","logistic"), 
  re = c("ar1_y","none","none","none"), #re = c("ar1_y","none","none","none"), use ar1 to est sel but later fixing all 
  initial_pars=list(
    c(0.1,0.25,0.5,1,1,1), # Commercial fleet
    c(2,0.3), # Spring NEFSC
    c(2,0.3), # Fall NEFSC
    c(2,0.3)), # DFO survey
  fix_pars = list(
    c(4:6), # Estimate param for each age
    c(NULL), # bc logistic, these only estimate 2 params so just want to fix first one
    c(NULL),
    c(NULL))
)

# CHENG SELECTIVITY
# fleet_pars <- c(5,1)
# index_pars <- c(2,1)
# sel <- list(model=rep("logistic",n_fleets+n_indices),
#             initial_pars=c(rep(list(fleet_pars),n_fleets),rep(list(index_pars),n_indices)))

# M Configuration
M <- list(model="constant",initial_means=array(c(0.57, 0.33, 0.26, 0.23, 0.22, 0.22), dim = c(n_stocks,n_regions,n_ages)))

sigma        <- "rec+1"
re_cor       <- "iid"
ini.opt      <- "equilibrium" 
sigma_vals   <-  array(0.5, dim = c(n_stocks, n_regions, n_ages)) # NAA sigma

# NAA config
NAA_re <- list(N1_model=rep(ini.opt,n_stocks),
               sigma=rep(sigma,n_stocks),
               cor=rep(re_cor,n_stocks),
               recruit_model = 3,  # rChanged from ALEX code
               sigma_vals = sigma_vals) 

####################################
##############  ECOV  ##############
####################################

years = basic_info$years

env.dat_me <- read.csv("CI_indices.csv")

env.dat_me <- env.dat_me%>%
  filter(Year > 1972)

env.dat_me$bt_temp <- mean(env.dat_me$bt_temp)

ecov_me <- list(
  label = "bt_temp",
  mean = as.matrix(env.dat_me$bt_temp),
  logsigma = 'est_1', # estimate obs sigma, 1 value shared across years
  year = env.dat_me$Year,
  use_obs = matrix(1, ncol=1, nrow=dim(env.dat_me)[1]),
  #lag =1,# use all obs (=1)
  process_model = "ar1") #, # "rw" or "ar1"

ecov_me$recruitment_how <- matrix("controlling-lag-1-linear") #add recruitment how to ecov_me

#Creating an object with no ECOV included
ecov_none <- ecov_me
ecov_none$mean <- rep(NA,length(ecov_me$mean))
ecov_none$use_obs <- matrix(0, nrow = nrow(ecov_me$use_obs), ncol = ncol(ecov_me$use_obs))


######################################
######################################
######################################

## Prepare `wham` input

input_NoEcov <- prepare_wham_input(basic_info = basic_info, 
                                   selectivity = sel2, 
                                   M = M, 
                                   NAA_re = NAA_re,
                                   ecov = ecov_none,
                                   catch_info = catch_info_use, 
                                   index_info = index_info_use, 
                                   F = F_info,
                                   age_comp = "logistic-normal-pool0") 

# input_NoEcov[["data"]][["index_Neff"]] # Should I be making these NAs or 0?
# Answer: safer to just set 0 in input$data$use_indices: let model don't use the data for those NA years

# input_NoEcov[["data"]][["Ecov_obs"]]

## Change Catch and Index Info

input <- prepare_wham_input(gb_dat) # this is the input from asap file

input_NoEcov$data$agg_index_sigma
input_NoEcov$data$use_indices
input_NoEcov$data$use_index_paa

input_NoEcov$data$agg_index_sigma[1:50,] = input$data$agg_index_sigma

input_NoEcov$data$use_indices[1:50,] = input$data$use_indices

input_NoEcov$data$use_index_paa[1:50,] = input$data$use_index_paa

# remove_agg, remove_agg_pointer, remove_agg_years
zero_years <- lapply(seq_len(ncol(input$data$use_indices)), function(j) which(input$data$use_indices[, j] == 0))
max_rows <- max(sapply(zero_years, length))
n_indices <- length(zero_years)
remove_agg_years1 <- matrix(NA, nrow = max_rows, ncol = n_indices)

for (j in seq_along(zero_years)) {
  len <- length(zero_years[[j]])
  remove_agg_years1[1:len, j] <- zero_years[[j]]
}

# remove_paa, remove_paa_pointer, remove_paa_years
zero_years <- lapply(seq_len(ncol(input$data$use_index_paa)), function(j) which(input$data$use_index_paa[, j] == 0))

max_rows <- max(sapply(zero_years, length))
n_indices <- length(zero_years)
remove_paa_years1 <- matrix(NA, nrow = max_rows, ncol = n_indices)

for (j in seq_along(zero_years)) {
  len <- length(zero_years[[j]])
  remove_paa_years1[1:len, j] <- zero_years[[j]]
}

input_NoEcov <- update_input_index_info(input_NoEcov, 
                                        agg_index_sigma = input_NoEcov$data$agg_index_sigma, 
                                        index_Neff = input_NoEcov$data$index_Neff,
                                        remove_agg = TRUE, remove_agg_pointer = 1:3, 
                                        remove_agg_years = remove_agg_years1,
                                        remove_paa = TRUE, remove_paa_pointer = 1:3, 
                                        remove_paa_years = remove_paa_years1) # Update input file


om <- fit_wham(input_NoEcov, do.fit = T, do.brps = T, MakeADFun.silent = FALSE, do.retro = FALSE, do.osa = FALSE)
check_convergence(om)
plot_wham_output(om, out.type = "html")
saveRDS(om, file = "fitted_om_NOECOV.rds")
