niter <- 200
#set up a storage matrix for our alternative parameter sets
pars.iter <- matrix(NA,nrow = niter, ncol=3)
colnames(pars.iter) <- c("log_K","log_r","log_sigma")
# generate the sets of parameter values
for (i in 1:niter) {
pars.iter[i,] <- mvtnorm::rmvnorm(1, mean = redfish$pars,
sigma = redfish$vcov)
}
# Now generate replicate model outputs
biomass.iter <- data.frame()
for (i in 1:niter) {
#here we calculate the biomass trajectory for each of the above sampled parameter vectors
biomass.iter <- rbind(biomass.iter,
data.frame(year = seq(min(data.years),
max(data.years)+1),
biomass = dynamics(pars.iter[i,], harvest),
iter = i))
}
biomass.iter
biomass.iter %>%
group_by(year) %>%
median_qi(biomass, .width = c(.5, .8, .95)) %>%
ggplot() +
geom_lineribbon(aes(x = year, y = biomass, ymin = .lower, ymax = .upper),
show.legend = FALSE) +
scale_fill_brewer() +
# theme_bw() +
geom_line(aes(y=harvest,x=year), data = tibble(harvest = harvest,
year = data.years),lty=2) +
geom_point(aes(y=index, x=year), data = data.frame(index=index,
year = data.years)) +
# geom_line(aes(y=biomass,x=year,group=iter,col=iter),data = subset(biomass.iter,iter%in%1:10)) +
ylab("Estimated B and C (million tonnes)") +
theme_bw() +
guides(scale = "none")
proj.years <- 2014:2034
##### Data generation
observe <- function(biomass, sigma) {
biomass * exp(rnorm(1, -0.5*(sigma**2), sigma))
}
# USING A FIXED TARGET EXPLOITATION RATE - calculates catch for next hear based on fixed percentage of most recent biomass estimate
control <- function(estimated.biomass, control.pars) {
H1 <- control.pars$H1
H2 <- control.pars$H2
Bmax <- control.pars$Bmax
B2 <- control.pars$B2
B1 <- control.pars$B1
harv <- ifelse(estimated.biomass >= B1, H1,
ifelse(estimated.biomass < B2, H2,
(H1-H2)/(B1-B2)*(estimated.biomass - B2) + H2))
return(harv)
#end function control
}
control.pars <- list()
control.pars$H1 <- 0.05
control.pars$H2 <- 0
control.pars$Bmax <- max(index, na.rm =TRUE)
control.pars$B2 <- 0.2*control.pars$Bmax
control.pars$B1 <- 0.5*control.pars$Bmax
implement <- function(TAC,...) {
TAC
}
evaluate <- function(pars.iter, biomass.iter,
control.pars, data.years, proj.years,
iterations, overshoot, ...) {
# function arguments:
# pars.iter & biomass.iter, the parameters & historical biomass trajectories of the operating model
# control.pars, the specifications of the harvest control rule
# set up some indexing values
iyr <- length(data.years)+1
pyr <- length(proj.years)
yrs <- c(data.years, proj.years, max(proj.years)+1)
# set up a data frame to store the results
res <- data.frame()
# loop over the iterations of the MSE, each iteration conducts a 20 year projection with annual generation of biomass
# observations and appliations of the control rule.
for(i in 1:iterations) {
#i = 1
#extract the parameters for this iteration
K.i <- exp(pars.iter[i,1])
r.i <- exp(pars.iter[i,2])
sig.i <- exp(pars.iter[i,3])
#set up vectors for time series of interest.
biomass.i <- c(subset(biomass.iter, iter==i)$biomass, numeric(pyr))
index.i <- c(index,numeric(pyr))
catch.i <- c(harvest, numeric(pyr))
TAC.i <- numeric(pyr)
# loop over the projection period.
for (y in iyr:(iyr+pyr-1)) {
#generate the data for the most recent year
index.i[y] <- observe(biomass.i[y] , sig.i)
#calculate the TAC based on the harvest control rule
# note that the control rule ONLY sees the index data, not the operating model biomass. WHYYYYYYYYYYYYYYYYYYYYYYYYYYYYYY
TAC.i [y] <- control(index.i[y], control.pars) * index.i[y]
#find the realized catch after implementation error
catch.i[y] <- implement(TAC.i[y], overshoot)
# update the true biomass of the operating model based on the output of the HCR
biomass.i[y+1] <- PT(biomass.i[y],catch.i[y],K.i,r.i)
#end projection year loop for iteration i
}
#store the results for this iteration
res <- rbind(res, data.frame(year = yrs[-length(yrs)],
value = index.i, type = "index", iter = i),
data.frame(year = yrs[-length(yrs)],
value = catch.i, type = "catch", iter=i),
data.frame(year = yrs, value = biomass.i,
type= "biomass", iter=i))
#end loop over iterations
}
res
return(res)
# #end function evaluate()
}
# Fixed 10% exploitation rate of est. biomass for all iterations and 20 yrs
project.fixed <- evaluate(pars.iter, biomass.iter, control.pars, data.years,
proj.years, niter, overshoot = NA)
knitr::opts_chunk$set(echo = FALSE)
library(ggplot2)
library(Hmisc)
library(mvtnorm)
write.dir <- "C:/Users/swulfing/OneDrive - University of Massachusetts Dartmouth/Documents/GitHub/UMassD/GavinMSECourse"
setwd(write.dir)
source("first-mse-functions.R")
#e.g
#schaefer
schaefer <- function(B,C,K,r) {
#function schaefer takes the current biomass, a catch,
#and the model parameters to compute next year's biomass
res <- B + B * r * (1 - (B/K)**(1.2-1)) - C
return(max(0.001,res)) # we add a constraint to prevent negative biomass
}
# BIOMASS PRODUCTION FXN
dynamics <- function(pars,C,yrs) {
# dynamics takes the model parameters, the time series of catch,
# & the yrs to do the projection over
# first extract the parameters from the pars vector (we estimate K in log-space)
K <- exp(pars[1])
r <- exp(pars[2])
#m <- exp(pars[3])
# find the total number of years
nyr <- length(C) + 1
# if the vector of years was not supplied we create
# a default to stop the program crashing
if (missing(yrs)) yrs <- 1:nyr
#set up the biomass vector
B <- numeric(nyr)
#intialize biomass at carrying capacity
B[1] <- K
# project the model forward using the schaefer model
for (y in 2:nyr) {
B[y] <- rnorm(1, schaefer(B[y-1],C[y-1],K,r), sd(harvest))
}
#return the time series of biomass
return(B[yrs])
#end function dynamics
}
# JUST USING LAST VIG
data.years <- 1991:2013
harvest <- c(0.1,3,15,52,76,139,95,93,84,93,86,103,104,
92,46,67,59,30,54,59,47,33,44)
index <- c(NA,NA,NA,NA,NA,NA,NA,NA,935,NA,1057,NA,678,NA,
420,NA,554,NA,458,NA,474,NA,280)
plot(data.years,index, pch=19,xlab="Year",ylab="Million tonnes (B/C)",
ylim=c(0,1200))
lines(data.years,harvest,lty=2,lwd=2)
# NOW RUN ASSESSMENT
ini.parms <- c(log(1200), log(0.1), log(0.3)) # Initial param vector for log(K), log(r), log(sigma), log m?
# FIT TO DATA
redfish <- assess(harvest,index,calc.vcov=TRUE,ini.parms)
redfish
# EXTRACT MAX LIKELIHOOD AND PARAM ESTIMATES
biomass.mle <- redfish$biomass
# print(biomass.mle)
pars.mle <- redfish$pars
# print(exp(pars.mle))
# To obtain a set of plausible alternatives for the parameters of the operating model, we will use the statistical uncertainty from the estimation by sampling parameter sets from the estimated variance-covariance matrix.
#define the number of iterations for the MSE
niter <- 200
#set up a storage matrix for our alternative parameter sets
pars.iter <- matrix(NA,nrow = niter, ncol=3)
colnames(pars.iter) <- c("log_K","log_r","log_sigma")
# generate the sets of parameter values
for (i in 1:niter) {
pars.iter[i,] <- mvtnorm::rmvnorm(1, mean = redfish$pars,
sigma = redfish$vcov)
}
# Now generate replicate model outputs
biomass.iter <- data.frame()
for (i in 1:niter) {
#here we calculate the biomass trajectory for each of the above sampled parameter vectors
biomass.iter <- rbind(biomass.iter,
data.frame(year = seq(min(data.years),
max(data.years)+1),
biomass = dynamics(pars.iter[i,], harvest),
iter = i))
}
biomass.iter
biomass.iter %>%
group_by(year) %>%
median_qi(biomass, .width = c(.5, .8, .95)) %>%
ggplot() +
geom_lineribbon(aes(x = year, y = biomass, ymin = .lower, ymax = .upper),
show.legend = FALSE) +
scale_fill_brewer() +
# theme_bw() +
geom_line(aes(y=harvest,x=year), data = tibble(harvest = harvest,
year = data.years),lty=2) +
geom_point(aes(y=index, x=year), data = data.frame(index=index,
year = data.years)) +
# geom_line(aes(y=biomass,x=year,group=iter,col=iter),data = subset(biomass.iter,iter%in%1:10)) +
ylab("Estimated B and C (million tonnes)") +
theme_bw() +
guides(scale = "none")
proj.years <- 2014:2034
##### Data generation
observe <- function(biomass, sigma) {
biomass * exp(rnorm(1, -0.5*(sigma**2), sigma))
}
# USING A FIXED TARGET EXPLOITATION RATE - calculates catch for next hear based on fixed percentage of most recent biomass estimate
control <- function(estimated.biomass, control.pars) {
H1 <- control.pars$H1
H2 <- control.pars$H2
Bmax <- control.pars$Bmax
B2 <- control.pars$B2
B1 <- control.pars$B1
harv <- ifelse(estimated.biomass >= B1, H1,
ifelse(estimated.biomass < B2, H2,
(H1-H2)/(B1-B2)*(estimated.biomass - B2) + H2))
return(harv)
#end function control
}
control.pars <- list()
control.pars$H1 <- 0.05
control.pars$H2 <- 0
control.pars$Bmax <- max(index, na.rm =TRUE)
control.pars$B2 <- 0.2*control.pars$Bmax
control.pars$B1 <- 0.5*control.pars$Bmax
implement <- function(TAC,...) {
TAC
}
evaluate <- function(pars.iter, biomass.iter,
control.pars, data.years, proj.years,
iterations, overshoot, ...) {
# function arguments:
# pars.iter & biomass.iter, the parameters & historical biomass trajectories of the operating model
# control.pars, the specifications of the harvest control rule
# set up some indexing values
iyr <- length(data.years)+1
pyr <- length(proj.years)
yrs <- c(data.years, proj.years, max(proj.years)+1)
# set up a data frame to store the results
res <- data.frame()
# loop over the iterations of the MSE, each iteration conducts a 20 year projection with annual generation of biomass
# observations and appliations of the control rule.
for(i in 1:iterations) {
#i = 1
#extract the parameters for this iteration
K.i <- exp(pars.iter[i,1])
r.i <- exp(pars.iter[i,2])
sig.i <- exp(pars.iter[i,3])
#set up vectors for time series of interest.
biomass.i <- c(subset(biomass.iter, iter==i)$biomass, numeric(pyr))
index.i <- c(index,numeric(pyr))
catch.i <- c(harvest, numeric(pyr))
TAC.i <- numeric(pyr)
# loop over the projection period.
for (y in iyr:(iyr+pyr-1)) {
#generate the data for the most recent year
index.i[y] <- observe(biomass.i[y] , sig.i)
#calculate the TAC based on the harvest control rule
# note that the control rule ONLY sees the index data, not the operating model biomass. WHYYYYYYYYYYYYYYYYYYYYYYYYYYYYYY
TAC.i [y] <- control(index.i[y], control.pars) * index.i[y]
#find the realized catch after implementation error
catch.i[y] <- implement(TAC.i[y], overshoot)
# update the true biomass of the operating model based on the output of the HCR
biomass.i[y+1] <- schaefer(biomass.i[y],catch.i[y],K.i,r.i)
#end projection year loop for iteration i
}
#store the results for this iteration
res <- rbind(res, data.frame(year = yrs[-length(yrs)],
value = index.i, type = "index", iter = i),
data.frame(year = yrs[-length(yrs)],
value = catch.i, type = "catch", iter=i),
data.frame(year = yrs, value = biomass.i,
type= "biomass", iter=i))
#end loop over iterations
}
res
return(res)
# #end function evaluate()
}
# Fixed 10% exploitation rate of est. biomass for all iterations and 20 yrs
project.fixed <- evaluate(pars.iter, biomass.iter, control.pars, data.years,
proj.years, niter, overshoot = NA)
tail(project.fixed)
# View trajectories of catch and om biomass from output
projection.plot <- function(project.results) {
# Fig2 <- ggplot(data = subset(project.results, type != "index"),
#  aes(x = year, y = value))
project.results %>%
filter(type %in% c("biomass","catch")) %>%
group_by(type, year) %>%
median_qi(value, .width = c(.5, .8, .95)) %>%
ggplot() +
geom_lineribbon(aes(x = year, y = value, ymin = .lower, ymax = .upper),
show.legend = FALSE) +
scale_fill_brewer() +
geom_line(aes(y=value,x=year),data = subset(project.results, type != "index" & iter==1 & year %in% proj.years), lty=1,lwd=1,col=gray(0.7)) +
geom_line(aes(y=value,x=year),data = subset(project.results, type != "index" & iter==2 & year %in% proj.years), lty=1,lwd=1,col=gray(0.7)) +
geom_line(aes(y=value,x=year),data = subset(project.results, type != "index" & iter==3 & year %in% proj.years), lty=1,lwd=1,col=gray(0.7)) +
# stat_summary(fun.data = "median_hilow", geom = "smooth", col="black",
#              fill = gray(0.5), lty = 2, aes=0.1) +
# stat_summary(fun = median, fun.min = function(x)0, geom="line",
#              data = subset(project.results, type != "index" & year %in% data.years), lwd=1) +
facet_wrap(~type, scale = "free_y") +
ylab("Million tonnes") +
theme_bw()
}
projection.plot(project.fixed)
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(furrr)
library(RcppRoll)
source("age-functions.R")
source("performance-metrics.R")
my_future_options <- future_options()
furrr_options <- future_options()
future_options <- furrr_options()
my_future_options$globals <- ls()
my_future_options <- furrr_options()
my_future_options$globals <- ls()
my_future_options$packages <- c("wham",
"tidyverse",
"dlm",
"RandomFieldsUtils")
future::plan(future::multisession)
# # ## read in biol data & create input object
#path <- "materials/exercises/day-02/"
input <- list()
input$nages <- scan("floundah_biology.txt",n=1,skip=9)
# # ## read in biol data & create input object
#path <- "materials/exercises/day-02/"
input <- list()
input$nages <- scan("floundah_biology.txt",n=1,skip=9)
nages <- input$nages
input$maturity <- scan("floundah_biology.txt",n=nages,skip=11)
input$selex <- scan("floundah_biology.txt",n=nages,skip=13)
input$weight <- scan("floundah_biology.txt",n=nages,skip=15)
#
input$M <- 0.4
input$Fmult <- 1 #proportion of FSPRtarg during historical period
input$SPRtarg <- 0.4
input$Rbar <- 1000
input$sigmaR <- 0.6
input$cpueCV <- 0.3
om_settings <- tibble(om=1,
input=list(input)) %>%
I()
om_settings$input
nsim <- 1000
set.seed(24601)
seeds <- ceiling(99999*runif(nsim))
sim_seeds <- tibble(isim = 1:nsim,
seed = seeds)
mse_sim_setup <- om_settings %>%
mutate(sim_seeds= list(sim_seeds)) %>%
unnest(cols = sim_seeds) %>%
rowid_to_column() %>%
select(rowid,everything()) %>%
ungroup() %>%
arrange(isim) %>%   # organizes so first realization of each is done first
I()
mse_sim_setup
### run the MSE over each row of the mse_sims todo
#add a safe mode (returns error safely rather than crashing)
safe_evaluate <- purrr::safely(evaluate, otherwise = NA_real_)
#do the MSE for all simulations and scenarios
#profvis::profvis(
#system.time(
mse_output <- mse_sim_setup %>%
#mutate(mse = furrr::future_pmap(list(seed = seed, input = input),
#safe_evaluate, .options = my_future_options)) %>%
# this is the regular purrr code for iterating over the simulations
mutate(mse = purrr::pmap(list(seed = seed, input = input), evaluate)) %>%
rowwise() %>%
mutate(om_SSB = list(mse$om_SSB)) %>%
mutate(om_F = list(mse$om_F)) %>%
mutate(tac = list(mse$tac)) %>%
mutate(ftarg = mse$ftarg) %>%
I()
mse_output
mse_results <- mse_output %>%
rowwise() %>%
mutate(bmsy = input$Rbar*SBPR(ftarg,input$M,input$weight,input$selex,input$maturity)) %>%
mutate(msy = input$Rbar*YPR(ftarg,input$M,input$weight,input$selex)) %>%
ungroup() %>%
mutate(ssb_metrics = pmap(list(om_SSB, bmsy), get_ssb_metrics, nprojyrs = 50),
catch_metrics = pmap(list(tac, msy), get_catch_metrics, nprojyrs = 50),
f_metrics = pmap(list(om_F, ftarg), get_F_metrics, nprojyrs = 50)) %>%
select(rowid, om, isim, ssb_metrics, catch_metrics, f_metrics) %>%
I()
mse_results
ssb_results <- mse_results %>%
select(rowid, om, isim, ssb_metrics) %>%
mutate(ssb_metrics = map(ssb_metrics, enframe)) %>%
unnest(cols = c(ssb_metrics)) %>%
mutate(value = map_dbl(value, I)) %>%
rename(metric = name) %>%
I()
ssb_results
unique(ssb_results$metric)
###pull out the f metrics
f_results <- mse_results %>%
select(rowid, om, isim, f_metrics) %>%
mutate(f_metrics = map(f_metrics, enframe)) %>%
unnest(cols = c(f_metrics)) %>%
mutate(value = map_dbl(value, I)) %>%
rename(metric = name) %>%
I()
f_results
unique(f_results$metric)
###pull out the catch metrics
catch_results <- mse_results %>%
select(rowid, om, isim, catch_metrics) %>%
mutate(catch_metrics = map(catch_metrics, enframe)) %>%
unnest(cols = c(catch_metrics)) %>%
mutate(value = map_dbl(value, I)) %>%
rename(metric = name) %>%
I()
catch_results
full_metrics <- bind_rows(ssb_results, catch_results, f_results)
quibble <- function(x, q = c(0.25, 0.5, 0.75)) {
tibble(x = quantile(x, q, na.rm = TRUE), q = q)
}
summary <- full_metrics %>%
group_by(metric, om) %>%
summarise(y = list(quibble(value, c(0.25, 0.5, 0.75)))) %>%
tidyr::unnest(y) %>%
I()
summary
knitr::opts_chunk$set(echo = FALSE)
#install.packages('ggplot2')
library(tidyverse)
library(ggdist)
library(Hmisc)
library(mvtnorm)
source("mse-functions.R")
data.years <- 1991:2013
harvest <- c(0.1,3,15,52,76,139,95,93,84,93,86,103,104,
92,46,67,59,30,54,59,47,33,44)
index <- c(NA,NA,NA,NA,NA,NA,NA,NA,935,NA,1057,NA,678,NA,
420,NA,554,NA,458,NA,474,NA,280)
# Load conditioned OM
schaefer_fit <- readRDS("schaefer_om.rds")
pars.iter <- schaefer_fit$pars
biomass.iter <- schaefer_fit$bio
# ApplY MSE
proj.years <- 2014:2034
project.emhcr <- em_evaluate(pars.iter, biomass.iter, control.pars,
data.years, proj.years, iterations=3, true.m = 2, est.m = 2)
knitr::opts_chunk$set(echo = FALSE)
#install.packages('ggplot2')
library(tidyverse)
library(ggdist)
library(Hmisc)
library(mvtnorm)
source("mse-functions.R")
data.years <- 1991:2013
harvest <- c(0.1,3,15,52,76,139,95,93,84,93,86,103,104,
92,46,67,59,30,54,59,47,33,44)
index <- c(NA,NA,NA,NA,NA,NA,NA,NA,935,NA,1057,NA,678,NA,
420,NA,554,NA,458,NA,474,NA,280)
# Load conditioned OM
schaefer_fit <- readRDS("schaefer_om.rds")
pars.iter <- schaefer_fit$pars
biomass.iter <- schaefer_fit$bio
# ApplY MSE
proj.years <- 2014:2034
project.emhcr <- em_evaluate(pars.iter, biomass.iter, control.pars,
data.years, proj.years, iterations=3, true.m = 2, est.m = 2)
knitr::opts_chunk$set(echo = FALSE)
#install.packages('ggplot2')
library(tidyverse)
library(ggdist)
library(Hmisc)
library(mvtnorm)
source("mse-functions.R")
data.years <- 1991:2013
harvest <- c(0.1,3,15,52,76,139,95,93,84,93,86,103,104,
92,46,67,59,30,54,59,47,33,44)
index <- c(NA,NA,NA,NA,NA,NA,NA,NA,935,NA,1057,NA,678,NA,
420,NA,554,NA,458,NA,474,NA,280)
# Load conditioned OM
schaefer_fit <- readRDS("schaefer_om.rds")
pars.iter <- schaefer_fit$pars
biomass.iter <- schaefer_fit$bio
# ApplY MSE
proj.years <- 2014:2034
data.years <- 1991:2013
harvest <- c(0.1,3,15,52,76,139,95,93,84,93,86,103,104,
92,46,67,59,30,54,59,47,33,44)
index <- c(NA,NA,NA,NA,NA,NA,NA,NA,935,NA,1057,NA,678,NA,
420,NA,554,NA,458,NA,474,NA,280)
# Load conditioned OM
schaefer_fit <- readRDS("schaefer_om.rds")
pars.iter <- schaefer_fit$pars
biomass.iter <- schaefer_fit$bio
# ApplY MSE
proj.years <- 2014:2034
project.emhcr <- evaluate(pars.iter, biomass.iter, control.pars,
data.years, proj.years, iterations=3, true.m = 2, est.m = 2)
